#!/usr/bin/env bash
# shellcheck source=../../../lib/utils
source "$DOTFILES_DIR"/src/lib/utils

error() {
    echo -e "${n}${RED}[ERROR]\t${NC}$1"
}

fatal() {
    echo -e "${n}${CYAN}[FATAL]\t${NC}$1"
    exit 1
}

util_terminal_colors() {
    for i in {0..255}; do
        printf "\x1b[48;5;%sm%3d\e[0m " "$i" "$i"
        if ((i == 15)) || ((i > 15)) && (((i - 15) % 6 == 0)); then
            printf "\n"
        fi
    done
}

gh_set_token() {
    unset GITHUB_TOKEN
    if ! gh auth status &>/dev/null; then
        gh auth login -h github.com
    fi
    token="$(gh config get -h github.com oauth_token)"
    export GITHUB_TOKEN="$token"
}

cs_actions_dev() {
    name=$(gh cs create -r github/github -b master)
    gh cs ssh -c "$name" -- "cd /workspaces/github && script/setup-codespaces-actions"
    gh cs code -c "$name"
}

cs_ghm_list() {
  gh cs list --json repository,name | jq '.[] | select(.repository | contains("github/github")) | .name' | fzf | cut -f1 | xargs gh cs code --codespace "$@"
}

cs_create_and_open() {
    local nwo=$1
    local ref=$2
    if help_arg "$1"; then
        echo "Usage: cs_create_and_open <nwo> <ref>"
        echo "create a codespace for the given ref and nwo, then open it in vscode"
        return
    fi
    codespace="$(gh cs create -r "$nwo" -b "$ref")"
    gh cs code -c "$codespace"
}

dot_reload() {
    # shellcheck disable=SC1090
    source ~/.zshrc
    # shellcheck source=../../../lib/utils
    source "$DOTFILES_DIR"/src/lib/utils
    tmux source-file ~/.tmux.conf
    if target_is_macos; then
        hs -c "hs.reload()"
    fi
}

util_untar() {
    tar -xvf "$1"
}

util_tar() {
    tar -cvzf "$1".tar.gz "$1"
}

install() {
    if target_is_macos; then
        cd "$DOTFILES_DIR" || fatal "couldn't cd to dotfiles dir, exiting"
        git stash -u
        brew install "$@"
        rm -f Brewfile Brewfile.lock.json
        brew bundle dump "$DOTFILES_DIR"/Brewfile
        brew update
        git add -A
        git commit -F- <<EOF
dotbot: brew sync on $(fatal_portable_hostname)
EOF
    else
        error "no install utility for this system"
    fi
}

fatal_portable_hostname() {
    if target_is_macos; then
        scutil --get LocalHostName
    else
        fatal "no portal hostname for this system, bailing"
    fi
}

function bw_set_session() {
    BW_SESSION=$(bw unlock --raw "$1")
    export BW_SESSION
    echo "BW_SESSION=$BW_SESSION" >>~/.zshrc.local
}

function nas_enter() {
    sshpass -p "$(bw get password nas.dundercloud.io)" ssh nas
}

function scratch_repo() {
    help="Usage: scratch_repo <repo_name>
creates a local and remote repository"
    if help_arg "$1" || [[ "$#" != 1 ]]; then
        echo "$help"
        return
    fi
    export name="$1-$(date '+%m-%d-%Y-%H-%M-%S')"
    (
        ghq create nodeselector/"$name"
        repo="$(ghq list --full-path nodeselector/"$name")"
        gh repo create --private --source "$repo" "$name"
    )
}


function forego_actions() {
    LAUNCH_DIR=/workspaces/actions/launch
    "$LAUNCH_DIR/script/docker-compose" down
    forego start -f "$DOTFILES_DIR/src/packages/forego/actions.codespaces.server.Procfile"
}

function launch_worker_key_path() {
code services/queueworker/worker.go pkg/processors/build/processor.go services/deploy/workflowinvoker/invoker.go services/deploy/workflowinvoker/workflowinvoker.go services/deploy/workflowinvoker/build_invoker.go
}

function vscode_open_nwo() {
	code "$HOME/ghq/github.com/$1"
}


# fbr - checkout git branch (including remote branches)
fbr() {
  local branches branch
  branches=$(git branch --all | grep -v HEAD) &&
  branch=$(echo "$branches" |
           fzf-tmux -d $(( 2 + $(wc -l <<< "$branches") )) +m) &&
  git checkout $(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")
}

# fco - checkout git branch/tag
fco() {
  local tags branches target
  branches=$(
    git --no-pager branch --all \
      --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%1B[0;34;1mbranch%09%1B[m%(refname:short)%(end)%(end)" \
    | sed '/^$/d') || return
  tags=$(
    git --no-pager tag | awk '{print "\x1b[35;1mtag\x1b[m\t" $1}') || return
  target=$(
    (echo "$branches"; echo "$tags") |
    fzf --no-hscroll --no-multi -n 2 \
        --ansi) || return
  git checkout $(awk '{print $2}' <<<"$target" )
}


# fco_preview - checkout git branch/tag, with a preview showing the commits between the tag/branch and HEAD
fco_preview() {
  local tags branches target
  branches=$(
    git --no-pager branch --all \
      --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%1B[0;34;1mbranch%09%1B[m%(refname:short)%(end)%(end)" \
    | sed '/^$/d') || return
  tags=$(
    git --no-pager tag | awk '{print "\x1b[35;1mtag\x1b[m\t" $1}') || return
  target=$(
    (echo "$branches"; echo "$tags") |
    fzf --no-hscroll --no-multi -n 2 \
        --ansi --preview="git --no-pager log -150 --pretty=format:%s '..{2}'") || return
  git checkout $(awk '{print $2}' <<<"$target" )
}

# fcs - get git commit sha
# example usage: git rebase -i `fcs`
fcs() {
  local commits commit
  commits=$(git log --color=always --pretty=oneline --abbrev-commit --reverse) &&
  commit=$(echo "$commits" | fzf --tac +s +m -e --ansi --reverse) &&
  echo -n $(echo "$commit" | sed "s/ .*//")
}

# fstash - easier way to deal with stashes
# type fstash to get a list of your stashes
# enter shows you the contents of the stash
# ctrl-d shows a diff of the stash against your current HEAD
# ctrl-b checks the stash out as a branch, for easier merging
fstash() {
  local out q k sha
  while out=$(
    git stash list --pretty="%C(yellow)%h %>(14)%Cgreen%cr %C(blue)%gs" |
    fzf --ansi --no-sort --query="$q" --print-query \
        --expect=ctrl-d,ctrl-b);
  do
    mapfile -t out <<< "$out"
    q="${out[0]}"
    k="${out[1]}"
    sha="${out[-1]}"
    sha="${sha%% *}"
    [[ -z "$sha" ]] && continue
    if [[ "$k" == 'ctrl-d' ]]; then
      git diff $sha
    elif [[ "$k" == 'ctrl-b' ]]; then
      git stash branch "stash-$sha" $sha
      break;
    else
      git stash show -p $sha
    fi
  done
}


# fdr - cd to selected parent directory
fdr() {
  local declare dirs=()
  get_parent_dirs() {
    if [[ -d "${1}" ]]; then dirs+=("$1"); else return; fi
    if [[ "${1}" == '/' ]]; then
      for _dir in "${dirs[@]}"; do echo $_dir; done
    else
      get_parent_dirs $(dirname "$1")
    fi
  }
  local DIR=$(get_parent_dirs $(realpath "${1:-$PWD}") | fzf-tmux --tac)
  cd "$DIR"
}
